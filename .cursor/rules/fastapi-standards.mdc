---
description: FastAPI development standards and best practices
globs: ["**/api/*.py", "**/routes/*.py", "**/main.py"]
alwaysApply: true
---

# FastAPI Development Standards

## API Design Principles

### RESTful Design
- Use proper HTTP methods: GET, POST, PUT, PATCH, DELETE
- Use meaningful resource-based URLs
- Return appropriate HTTP status codes
- Implement proper error handling and responses

### API Structure
```python
from fastapi import FastAPI, HTTPException, Depends, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from loguru import logger
import asyncio

# =============================== Data Models =============================== #
class WorkflowRequest(BaseModel):
    """Request model for starting a workflow."""
    workflow_type: str = Field(..., description="Type of workflow to execute")
    input_data: Dict[str, Any] = Field(..., description="Input data for the workflow")
    user_id: str = Field(..., description="ID of the user initiating the workflow")

    class Config:
        schema_extra = {
            "example": {
                "workflow_type": "data_processing",
                "input_data": {"file_path": "/path/to/file", "options": {}},
                "user_id": "user_123"
            }
        }

class WorkflowResponse(BaseModel):
    """Response model for workflow operations."""
    workflow_id: str = Field(..., description="Unique identifier for the workflow")
    status: str = Field(..., description="Current status of the workflow")
    message: str = Field(..., description="Human-readable message")
    created_at: str = Field(..., description="ISO timestamp when workflow was created")

class ErrorResponse(BaseModel):
    """Standard error response model."""
    error: str = Field(..., description="Error type")
    message: str = Field(..., description="Human-readable error message")
    details: Optional[Dict[str, Any]] = Field(None, description="Additional error details")

# =============================== API Routes =============================== #
app = FastAPI(
    title="Temporal Workflow API",
    description="API for managing Temporal workflows",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure appropriately for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc: HTTPException):
    """Handle HTTP exceptions with consistent error format."""
    logger.error(f"HTTP error {exc.status_code}: {exc.detail}")
    return JSONResponse(
        status_code=exc.status_code,
        content=ErrorResponse(
            error="HTTP_ERROR",
            message=exc.detail,
            details={"status_code": exc.status_code}
        ).dict()
    )

@app.exception_handler(Exception)
async def general_exception_handler(request, exc: Exception):
    """Handle unexpected exceptions."""
    logger.error(f"Unexpected error: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content=ErrorResponse(
            error="INTERNAL_ERROR",
            message="An unexpected error occurred",
            details={"exception_type": type(exc).__name__}
        ).dict()
    )
```

## Route Design Patterns

### Workflow Management Routes
```python
from fastapi import APIRouter, Depends, BackgroundTasks
from temporalio.client import Client
from datetime import datetime

router = APIRouter(prefix="/api/v1/workflows", tags=["workflows"])

# Dependency for Temporal client
async def get_temporal_client() -> Client:
    """Get Temporal client instance."""
    return await Client.connect("localhost:7233")

@router.post("/start", response_model=WorkflowResponse)
async def start_workflow(
    request: WorkflowRequest,
    background_tasks: BackgroundTasks,
    client: Client = Depends(get_temporal_client)
) -> WorkflowResponse:
    """Start a new workflow instance."""
    try:
        logger.info(f"Starting workflow: {request.workflow_type} for user {request.user_id}")

        # Start workflow asynchronously
        workflow_handle = await client.start_workflow(
            workflow_type=request.workflow_type,
            args=[request.input_data],
            id=f"{request.workflow_type}_{request.user_id}_{datetime.now().timestamp()}",
            task_queue="default"
        )

        # Add cleanup task to background
        background_tasks.add_task(
            _log_workflow_start,
            workflow_handle.id,
            request.workflow_type
        )

        return WorkflowResponse(
            workflow_id=workflow_handle.id,
            status="STARTED",
            message="Workflow started successfully",
            created_at=datetime.now().isoformat()
        )

    except Exception as e:
        logger.error(f"Failed to start workflow: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to start workflow: {str(e)}"
        )

@router.get("/{workflow_id}/status", response_model=WorkflowResponse)
async def get_workflow_status(
    workflow_id: str,
    client: Client = Depends(get_temporal_client)
) -> WorkflowResponse:
    """Get the current status of a workflow."""
    try:
        workflow_handle = client.get_workflow_handle(workflow_id)
        status = await workflow_handle.describe()

        return WorkflowResponse(
            workflow_id=workflow_id,
            status=status.status.name,
            message=f"Workflow is {status.status.name.lower()}",
            created_at=status.start_time.isoformat()
        )

    except Exception as e:
        logger.error(f"Failed to get workflow status: {e}")
        raise HTTPException(
            status_code=404,
            detail=f"Workflow {workflow_id} not found"
        )

@router.post("/{workflow_id}/signal")
async def signal_workflow(
    workflow_id: str,
    signal_data: Dict[str, Any],
    client: Client = Depends(get_temporal_client)
) -> JSONResponse:
    """Send a signal to a running workflow."""
    try:
        workflow_handle = client.get_workflow_handle(workflow_id)
        await workflow_handle.signal("workflow_signal", signal_data)

        return JSONResponse(
            content={"message": "Signal sent successfully"}
        )

    except Exception as e:
        logger.error(f"Failed to send signal: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to send signal: {str(e)}"
        )

@router.get("/{workflow_id}/result")
async def get_workflow_result(
    workflow_id: str,
    client: Client = Depends(get_temporal_client)
) -> JSONResponse:
    """Get the result of a completed workflow."""
    try:
        workflow_handle = client.get_workflow_handle(workflow_id)
        result = await workflow_handle.result()

        return JSONResponse(
            content={
                "workflow_id": workflow_id,
                "result": result,
                "status": "COMPLETED"
            }
        )

    except Exception as e:
        logger.error(f"Failed to get workflow result: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get workflow result: {str(e)}"
        )

# Background task functions
async def _log_workflow_start(workflow_id: str, workflow_type: str) -> None:
    """Log workflow start in background."""
    logger.info(f"Workflow {workflow_id} of type {workflow_type} started")
```

## Middleware and Dependencies

### Authentication Middleware
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from typing import Optional

security = HTTPBearer()

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> str:
    """Extract and validate user from JWT token."""
    try:
        # Implement JWT validation logic here
        # This is a placeholder implementation
        token = credentials.credentials
        user_id = validate_jwt_token(token)  # Your JWT validation function

        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication credentials",
                headers={"WWW-Authenticate": "Bearer"},
            )

        return user_id

    except Exception as e:
        logger.error(f"Authentication error: {e}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

def validate_jwt_token(token: str) -> Optional[str]:
    """Validate JWT token and return user ID."""
    # Implement your JWT validation logic
    pass
```

### Rate Limiting
```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

@router.post("/start")
@limiter.limit("10/minute")  # Rate limit: 10 requests per minute
async def start_workflow_limited(request: Request, ...):
    """Rate-limited workflow start endpoint."""
    pass
```

## Error Handling

### Custom Exception Classes
```python
class WorkflowError(Exception):
    """Base exception for workflow-related errors."""
    pass

class WorkflowNotFoundError(WorkflowError):
    """Exception raised when workflow is not found."""
    pass

class WorkflowExecutionError(WorkflowError):
    """Exception raised when workflow execution fails."""
    pass

# Custom exception handlers
@app.exception_handler(WorkflowNotFoundError)
async def workflow_not_found_handler(request, exc: WorkflowNotFoundError):
    """Handle workflow not found errors."""
    return JSONResponse(
        status_code=404,
        content=ErrorResponse(
            error="WORKFLOW_NOT_FOUND",
            message=str(exc)
        ).dict()
    )
```

## Testing Standards

### API Testing
```python
from fastapi.testclient import TestClient
import pytest

@pytest.fixture
def client():
    """Create test client."""
    return TestClient(app)

@pytest.fixture
def mock_temporal_client():
    """Mock Temporal client for testing."""
    # Mock implementation
    pass

def test_start_workflow_success(client, mock_temporal_client):
    """Test successful workflow start."""
    response = client.post(
        "/api/v1/workflows/start",
        json={
            "workflow_type": "test_workflow",
            "input_data": {"test": "data"},
            "user_id": "test_user"
        }
    )

    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "STARTED"
    assert "workflow_id" in data

def test_get_workflow_status_not_found(client, mock_temporal_client):
    """Test getting status of non-existent workflow."""
    response = client.get("/api/v1/workflows/non-existent/status")
    assert response.status_code == 404
```

## Best Practices

### API Design
- Use Pydantic models for request/response validation
- Implement proper error handling with consistent error responses
- Use appropriate HTTP status codes
- Document APIs with OpenAPI/Swagger
- Implement rate limiting for production use
- Use dependency injection for external services

### Performance
- Use async/await for I/O operations
- Implement proper caching strategies
- Use background tasks for non-critical operations
- Monitor API performance and response times

### Security
- Implement proper authentication and authorization
- Validate all input data
- Use HTTPS in production
- Implement proper CORS policies
- Sanitize error messages to avoid information leakage
