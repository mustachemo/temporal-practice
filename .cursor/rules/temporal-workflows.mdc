---
description: Temporal workflow and activity development standards
globs: ["**/workflows/*.py", "**/activities/*.py", "**/workers/*.py"]
alwaysApply: true
---

# Temporal Workflow Development Standards

## Workflow Design Principles

### Workflow Functions
- **Deterministic**: Workflows must be deterministic. No random operations, time-based operations, or external state access.
- **Idempotent**: Workflows should be idempotent and handle retries gracefully.
- **Versioning**: Always version workflow functions for backward compatibility.
- **Naming**: Use descriptive names that clearly indicate the workflow's purpose.

### Workflow Structure
```python
from dataclasses import dataclass
from typing import Any, Dict, List, Optional
from temporalio import workflow

@dataclass
class WorkflowInput:
    """Input data structure for the workflow."""
    request_id: str
    user_id: str
    parameters: Dict[str, Any]

@dataclass
class WorkflowResult:
    """Output data structure for the workflow."""
    success: bool
    result_data: Optional[Dict[str, Any]] = None
    error_message: Optional[str] = None

@workflow.defn
class ComplexWorkflow:
    """Complex workflow demonstrating best practices."""

    def __init__(self) -> None:
        self.logger = workflow.logger()

    @workflow.run
    async def run(self, input_data: WorkflowInput) -> WorkflowResult:
        """Main workflow execution method."""
        try:
            self.logger.info(f"Starting workflow for request {input_data.request_id}")

            # Execute workflow steps
            result = await self._execute_workflow_steps(input_data)

            self.logger.info(f"Workflow completed successfully for {input_data.request_id}")
            return WorkflowResult(success=True, result_data=result)

        except Exception as e:
            self.logger.error(f"Workflow failed for {input_data.request_id}: {e}")
            return WorkflowResult(success=False, error_message=str(e))

    async def _execute_workflow_steps(self, input_data: WorkflowInput) -> Dict[str, Any]:
        """Execute the main workflow logic."""
        # Workflow implementation here
        pass
```

## Activity Functions

### Activity Design
- **Pure Functions**: Activities should be pure functions with no side effects beyond their intended purpose.
- **Idempotent**: Activities must be idempotent and handle retries gracefully.
- **Error Handling**: Use specific exception types for different error conditions.
- **Logging**: Log activity start, completion, and any errors.

### Activity Structure
```python
from dataclasses import dataclass
from typing import Any, Dict, List, Optional
from temporalio import activity
from loguru import logger

@dataclass
class ActivityInput:
    """Input data structure for activities."""
    data: Dict[str, Any]
    metadata: Optional[Dict[str, Any]] = None

@dataclass
class ActivityResult:
    """Output data structure for activities."""
    success: bool
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

@activity.defn
async def process_data_activity(input_data: ActivityInput) -> ActivityResult:
    """Process data with proper error handling and logging."""
    logger.info(f"Starting data processing activity")

    try:
        # Activity implementation
        result = await _perform_data_processing(input_data.data)

        logger.info("Data processing activity completed successfully")
        return ActivityResult(success=True, data=result)

    except ValueError as e:
        logger.error(f"Validation error in data processing: {e}")
        return ActivityResult(success=False, error=f"Validation error: {e}")
    except Exception as e:
        logger.error(f"Unexpected error in data processing: {e}")
        return ActivityResult(success=False, error=f"Unexpected error: {e}")

async def _perform_data_processing(data: Dict[str, Any]) -> Dict[str, Any]:
    """Internal function for data processing logic."""
    # Implementation here
    pass
```

## Workflow Patterns

### Sequential Execution
```python
# Execute activities in sequence
result1 = await workflow.execute_activity(
    activity1, input_data1, start_to_close_timeout=timedelta(minutes=5)
)
result2 = await workflow.execute_activity(
    activity2, input_data2, start_to_close_timeout=timedelta(minutes=5)
)
```

### Parallel Execution
```python
# Execute activities in parallel
async def parallel_activities(input_data: WorkflowInput) -> Dict[str, Any]:
    """Execute multiple activities in parallel."""
    tasks = [
        workflow.execute_activity(activity1, input_data.part1),
        workflow.execute_activity(activity2, input_data.part2),
        workflow.execute_activity(activity3, input_data.part3),
    ]

    results = await asyncio.gather(*tasks, return_exceptions=True)

    # Handle results and exceptions
    processed_results = {}
    for i, result in enumerate(results):
        if isinstance(result, Exception):
            logger.error(f"Activity {i} failed: {result}")
            processed_results[f"activity_{i}"] = None
        else:
            processed_results[f"activity_{i}"] = result

    return processed_results
```

### Conditional Execution
```python
# Conditional workflow execution
if input_data.requires_validation:
    validation_result = await workflow.execute_activity(
        validate_data_activity, input_data, start_to_close_timeout=timedelta(minutes=2)
    )

    if not validation_result.success:
        return WorkflowResult(success=False, error_message="Validation failed")
```

### Error Handling & Retries
```python
from temporalio.common import RetryPolicy

# Configure retry policy
retry_policy = RetryPolicy(
    initial_interval=timedelta(seconds=1),
    maximum_interval=timedelta(seconds=60),
    maximum_attempts=3,
    backoff_coefficient=2.0,
)

result = await workflow.execute_activity(
    risky_activity,
    input_data,
    start_to_close_timeout=timedelta(minutes=10),
    retry_policy=retry_policy,
)
```

## Worker Configuration

### Worker Setup
```python
from temporalio.client import Client
from temporalio.worker import Worker
import asyncio

async def main():
    """Main worker function."""
    # Connect to Temporal server
    client = await Client.connect("localhost:7233")

    # Create worker
    worker = Worker(
        client,
        task_queue="your-task-queue",
        workflows=[ComplexWorkflow],
        activities=[process_data_activity, validate_data_activity],
    )

    # Start worker
    await worker.run()

if __name__ == "__main__":
    asyncio.run(main())
```

## Best Practices

### Workflow Design
- Keep workflows focused on orchestration, not business logic.
- Use activities for all external interactions (APIs, databases, file I/O).
- Design for failure and implement proper error handling.
- Use workflow signals for external communication.
- Implement workflow queries for status checking.

### Activity Design
- Keep activities stateless and idempotent.
- Use appropriate timeouts for different activity types.
- Implement proper retry policies.
- Log activity execution details.
- Handle partial failures gracefully.

### Testing
- Write unit tests for activities.
- Use workflow testing utilities for workflow testing.
- Mock external dependencies in tests.
- Test error scenarios and retry logic.
